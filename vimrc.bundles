" ======================
" vim-plug插件配置与安装
" ======================

" =============== 依赖说明 ===============[[[1
" Python依赖: pip install flake8 pep8-naming isort jedi
" ]]]

" ================= 插件管理 =====================[[[1
if !exists('g:bundle_groups')  " inspired by spf13, 自定义需要的插件集合
    " \'latex',
    let g:bundle_groups=[
        \'python',
        \'beta',
        \'markdown',
        \'nginx',
        \'go',
        \]
endif

call plug#begin('~/.config/nvim/bundle')
    " 自动补全插件[[[2
        " 代码片段快速插入
        Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'
        " 自动补全单引号，双引号等
        Plug 'Raimondi/delimitMate'
        Plug 'Valloric/YouCompleteMe'
    " ]]]

    " 编辑插件[[[2
        " 快速注释
        Plug 'tpope/vim-commentary'
        " 快速加入修改环绕字符
        Plug 'tpope/vim-surround'
        " 快速去行尾空格
        Plug 'ntpeters/vim-better-whitespace'
        " 多光标选中编辑
        Plug 'terryma/vim-multiple-cursors'
        " 格式化Python
        Plug 'google/yapf', { 'rtp': 'plugins/vim', 'for': 'python' }
        " 查看 Vim 的 undo 历史
        Plug 'mbbill/undotree', { 'on': 'UndotreeToggle' }
    " ]]]

    " 快速定位插件 [[[2
        " 文件内快速定位
        Plug 'easymotion/vim-easymotion'

        " fzf
        Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
        Plug 'junegunn/fzf.vim'
    " ]]]

    " 功能插件[[[2
        Plug 'tpope/vim-fugitive'
        Plug 'w0rp/ale'
        Plug 'tpope/vim-rhubarb'
    " ]]]

    " 显示插件[[[2
        " 括号显示增强
        Plug 'kien/rainbow_parentheses.vim'
        " 主题 solarized
        Plug 'altercation/vim-colors-solarized'

        " 显示Mark
        Plug 'kshenoy/vim-signature'

        " 状态行增强
        " Plug 'vim-airline/vim-airline'
    " ]]]

    " 导航插件[[[2
        " nerdtree nerdtreetabs
        Plug 'scrooloose/nerdtree' | Plug 'jistr/vim-nerdtree-tabs'
        " tagbar
        Plug 'majutsushi/tagbar'
    " ]]]

    " 语言相关[[[2
        " markdown[[[3
        if count(g:bundle_groups, 'markdown')
            Plug 'plasticboy/vim-markdown', {'for': 'md'}
        endif
        " ]]]

        " Python[[[3
        if count(g:bundle_groups, 'python')
            " for python.vim syntax highlight
            " pythonsyntax
            Plug 'hdima/python-syntax'
        endif
        " ]]]

        " Nginx[[[3
        if count(g:bundle_groups, 'nginx')
            Plug 'bwangel23/nginx-vim-syntax'
        endif
        " ]]]

        " Go[[[3
        if count(g:bundle_groups, 'go')
            Plug 'fatih/vim-go', {'for': 'go'}
        endif
        " ]]]
    " ]]]
    if count(g:bundle_groups, 'beta')
    endif
call plug#end()
" ]]]

" ==================== 插件配置 ========================[[[1
    " 自动补全插件[[[2
        " ultisnips [[[3
            let g:UltiSnipsExpandTrigger       = "<tab>"
            " 定义存放代码片段的文件夹 .vim/UltiSnips下，使用自定义和默认的，将会的到全局，有冲突的会提示
            let g:UltiSnipsSnippetsDir = '~/.vim/UltiSnips'
            " 进入对应filetype的snippets进行编辑
            map <leader>n :UltiSnipsEdit<CR>

            " ctrl+j/k 进行选择
            func! g:JInYCM()
                if pumvisible()
                    return "\<C-n>"
                else
                    return "\<c-j>"
                endif
            endfunction

            func! g:KInYCM()
                if pumvisible()
                    return "\<C-p>"
                else
                    return "\<c-k>"
                endif
            endfunction
            inoremap <c-j> <c-r>=g:JInYCM()<cr>
            au BufEnter,BufRead * exec "inoremap <silent> " . g:UltiSnipsJumpBackwordTrigger . " <C-R>=g:KInYCM()<cr>"
            let g:UltiSnipsJumpBackwordTrigger = "<c-k>"
        " ]]]
        " YouCompleteMe [[[3
            let g:ycm_key_list_select_completion=['<c-n>']
            let g:ycm_key_list_previous_completion=['<c-p>']
            let g:ycm_auto_trigger = 99
            let g:ycm_min_num_of_chars_for_completion = 3

            let g:ycm_complete_in_comments = 1  "在注释输入中也能补全
            let g:ycm_use_ultisnips_completer = 1 "提示UltiSnips
            " let g:ycm_complete_in_strings = 1   "在字符串输入中也能补全
            " let g:ycm_collect_identifiers_from_comments_and_strings = 1
            " let g:ycm_collect_identifiers_from_tags_files = 1

            " 开启语法关键字补全
            let g:ycm_seed_identifiers_with_syntax = 1
            " 设置Python解释器的路径
            if has('mac')
                let g:ycm_server_python_interpreter = '/usr/local/bin/python'
            else
                let g:ycm_server_python_interpreter = '/usr/bin/python'
            endif
            " 设置补全时用到的Python解释器的路径
            let g:ycm_python_binary_path = 'python2'

            if !empty(glob("~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py"))
                let g:ycm_global_ycm_extra_conf = "~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py"
            endif

            let g:ycm_show_diagnostics_ui = 1

            " 跳转到定义处, 水平分屏打开
            let g:ycm_goto_buffer_command = 'horizontal-split'
            nnoremap <leader>d :YcmCompleter GoToDefinition<CR>

            " 黑名单,不启用
            let g:ycm_filetype_blacklist = {
                \ 'tagbar' : 1,
                \ 'gitcommit' : 1,
                \ 'nerdtree': 1,
                \ 'zsh': 1,
                \}
        " ]]]
        " delimitMate [[[3
            " for python docstring ",优化输入
            au FileType python let b:delimitMate_nesting_quotes = ['"']
            au FileType php let delimitMate_matchpairs = "(:),[:],{:}"
            " 关闭某些类型文件的自动补全
            "au FileType mail let b:delimitMate_autoclose = 0
        " ]]]
    " ]]]

    " 编辑插件[[[2
        " vim-commentary [[[3
            autocmd FileType nginx setlocal commentstring=#\ %s
            autocmd FileType sql setlocal commentstring=--\ %s
            autocmd FileType awk setlocal commentstring=#\ %s
        " ]]]
        " trailingwhitespace [[[
            map <leader>t :StripWhitespace<CR>
            autocmd FileType c,cpp,java,go,puppet,python,rust,twig,xml,yml,perl autocmd BufEnter <buffer> EnableStripWhitespaceOnSave
        " ]]]
        " multiplecursors [[[3
            let g:multi_cursor_use_default_mapping=0
            " Default mapping
            let g:multi_cursor_next_key='<C-m>'
            let g:multi_cursor_prev_key='<C-p>'
            let g:multi_cursor_skip_key='<C-x>'
            let g:multi_cursor_quit_key='<Esc>'
        " ]]]
        " yapf [[[3
            autocmd FileType python nnoremap <leader>= :0,$!yapf --style ~/.vim/config/style.yapf<Cr>
            autocmd FileType python vnoremap <leader>= :!yapf --style ~/.vim/config/style.yapf<Cr>
        " ]]]
        " undotree [[[3
            if has("persistent_undo")
                set undodir=~/.undodir/
                set undofile
            endif
        " ]]]
    " ]]]
    " 快速定位插件[[[2
        " vim-easymotion [[[3
            let g:EasyMotion_smartcase = 1
            map <leader>j <Plug>(easymotion-j)
            map <leader>k <Plug>(easymotion-k)
            " 重复上一次操作, 类似repeat插件, 很强大
            map <leader>. <Plug>(easymotion-repeat)
        " ]]]
        " fzf [[[3
        " ]]]
        " fzf.vim[[[3
            " 显示所有Buffer
            command! -bang -nargs=* Ag
                \ call fzf#vim#ag(<q-args>,
                \                 <bang>0 ? fzf#vim#with_preview('up:60%')
                \                         : fzf#vim#with_preview('right:50%:hidden', '?'),
                \                 <bang>0)

            nnoremap <Leader>q :Ag<Space>
            xnoremap <silent> <Leader>q y:Ag <C-R>"<CR>
            nnoremap <silent> <Leader>` :Marks<CR>
            nnoremap <leader>p :Files<CR>
            " xnoremap <silent> <Leader>p y:Files <C-R>"<CR>
            nnoremap <silent> <Leader>l  :Buffers<CR>
            nnoremap <leader>m :Maps<CR>
            nnoremap <silent> <Leader><Enter>        :BLines<CR>
            nnoremap <leader>c :Commits<CR>
            nnoremap <leader>h :BTags<CR>
            xnoremap <silent> <Leader>h y:BTags <C-R>"<CR>
            let g:fzf_action = {
              \ 'ctrl-t': 'tab split',
              \ 'ctrl-s': 'split',
              \ 'ctrl-v': 'vsplit' }
            let g:fzf_layout = { 'window': '30split enew', 'down': '~40%' }
            let g:fzf_colors =
            \ { 'fg':      ['fg', 'Normal'],
                \ 'bg':      ['bg', 'Normal'],
                \ 'hl':      ['fg', 'Comment'],
                \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
                \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
                \ 'hl+':     ['fg', 'Statement'],
                \ 'info':    ['fg', 'PreProc'],
                \ 'border':  ['fg', 'Ignore'],
                \ 'prompt':  ['fg', 'Conditional'],
                \ 'pointer': ['fg', 'Exception'],
                \ 'marker':  ['fg', 'Keyword'],
                \ 'spinner': ['fg', 'Label'],
                \ 'header':  ['fg', 'Comment'] }
        " ]]]
    " ]]]
    " 功能插件[[[2
        " vim-fugitive [[[3
            " :Gdiff  :Gstatus :Gvsplit
            nnoremap <leader>ge :Gdiff<CR>
            nmap     <Leader>g :Gstatus<CR>gg<c-n>
        " ]]]
        " ale [[[3
            " pip install flake8 isort
            let g:ale_linters = {
            \   'python': ['flake8'],
            \}

            let g:ale_fixers = {
            \   'python': ['isort'],
            \}

            " http://pep8.readthedocs.io/en/latest/intro.html#error-codes
            " http://flake8.pycqa.org/en/latest/user/error-codes.html
            let g:ale_python_flake8_options="--ignore=E114,E116,E131 --max-line-length=80"
            let g:ale_lint_delay = 2000

            let g:ale_sign_column_always = 1

            nmap <silent> <C-p> <Plug>(ale_previous_wrap)
            nmap <silent> <C-n> <Plug>(ale_next_wrap)
            nmap <silent> <Leader>y <Plug>(ale_fix)

            let g:ale_sign_error = '>>'
            let g:ale_sign_warning = '__'
            let g:ale_deprecation_ale_statusline_status = 1
            let g:ale_deprecation_ale_get_status_line = 1

            let g:ale_statusline_format = ['⨉ %d', '⚠ %d', '⬥ ok']
            let g:ale_echo_msg_error_str = 'E'
            let g:ale_echo_msg_warning_str = 'W'
            let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'

            nnoremap <silent> <Leader>ec :ALEToggle<CR>

            " troggle quickfix list
            function! ToggleErrors()
                let old_last_winnr = winnr('$')
                lclose
                if old_last_winnr == winnr('$')
                    " Nothing was closed, open syntastic_error location panel
                    lopen
                endif
            endfunction
            " nnoremap <Leader>s :call ToggleErrors()<cr>

            let g:ale_set_highlights = 1
            highlight clear ALEErrorSign
            highlight clear ALEWarningSign

        " ]]]
    " ]]]

    " 显示插件[[[2
        " rainbow_parentheses [[[3
            " 不加入这行, 防止黑色括号出现, 很难识别
            " \ ['black',       'SeaGreen3'],
            let g:rbpt_colorpairs = [
                \ ['brown',       'RoyalBlue3'],
                \ ['Darkblue',    'SeaGreen3'],
                \ ['darkgray',    'DarkOrchid3'],
                \ ['darkgreen',   'firebrick3'],
                \ ['darkcyan',    'RoyalBlue3'],
                \ ['darkred',     'SeaGreen3'],
                \ ['darkmagenta', 'DarkOrchid3'],
                \ ['brown',       'firebrick3'],
                \ ['gray',        'RoyalBlue3'],
                \ ['darkmagenta', 'DarkOrchid3'],
                \ ['Darkblue',    'firebrick3'],
                \ ['darkgreen',   'RoyalBlue3'],
                \ ['darkcyan',    'SeaGreen3'],
                \ ['darkred',     'DarkOrchid3'],
                \ ['red',         'firebrick3'],
                \ ]

            let g:rbpt_max = 16
            let g:rbpt_loadcmd_toggle = 0
            au VimEnter * RainbowParenthesesToggle
            au Syntax * RainbowParenthesesLoadRound
            au Syntax * RainbowParenthesesLoadSquare
            au Syntax * RainbowParenthesesLoadBraces
        " ]]]
        " solarized [[[3
            let g:solarized_termtrans=1
            let g:solarized_contrast="normal"
            let g:solarized_visibility="normal"
        " ]]]
        " vim-airline [[[3
            if !exists('g:airline_symbols')
                let g:airline_symbols = {}
            endif
            let g:airline_left_sep = '▶'
            let g:airline_left_alt_sep = '❯'
            let g:airline_right_sep = '◀'
            let g:airline_right_alt_sep = '❮'
            let g:airline_symbols.linenr = '¶'
            let g:airline_symbols.branch = '⎇'
            let g:airline_section_z = '[%n] %P %L :%c'
            let g:airline_section_y = '%{airline#util#wrap(airline#parts#ffenc(),0)} %B'
        " ]]]
    " ]]]

    " 导航插件[[[2
        " nerdtree nerdtreetabs [[[3
            function! ChangeDirIntoCurrentBuffer()
                cd %:p:h
                NERDTreeCWD
            endfunction

            noremap <F3> :NERDTreeToggle<CR>
            noremap <leader>o :call ChangeDirIntoCurrentBuffer()<CR>
            let NERDTreeHighlightCursorline=1
            " 自动删除掉通过NERDTree删除的文件的Buffer
            let NERDTreeAutoDeleteBuffer=1
            " 设置NERDTree要忽略的文件
            let NERDTreeIgnore=[ '__pycache__$[[dir]]', 'node_modules$', '\.pyc$', '\.pyo$', '\.obj$', '\.o$', '\.so$', '\.egg$', '^\.git$', '^\.svn$', '^\.hg$', '^venv$' ]
            "close vim if the only window left open is a NERDTree
            autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | end
            " s/v 分屏打开文件
            let g:NERDTreeMapOpenSplit = 's'
            let g:NERDTreeMapOpenVSplit = 'v'

            " nerdtreetabs
            " 关闭同步
            " let g:nerdtree_tabs_synchronize_view=0
            " let g:nerdtree_tabs_synchronize_focus=0
            " 是否自动开启nerdtree
            let g:nerdtree_tabs_open_on_console_startup=0
            let g:nerdtree_tabs_open_on_gui_startup=0
        " ]]]
        " tagbar [[[3
            nmap <F8> :TagbarToggle<CR>
            let g:tagbar_width = 54
            let g:tagbar_sort = 0
            let g:tagbar_indent = 1
            let g:tagbar_compact = 1
            let g:tagbar_silent = 1
            let g:tagbar_iconchars = ['▸', '▾']

            " go语言的tagbar配置
            " 1. install gotags 'go get -u github.com/jstemmer/gotags'
            " 2. make sure `gotags` in you shell PATH, you can call check it with `which gotags`
            " for gotags. work with tagbar
            let g:tagbar_type_go = {
                \ 'ctagstype' : 'go',
                \ 'kinds'     : [
                    \ 'p:package',
                    \ 'i:imports:1',
                    \ 'c:constants',
                    \ 'v:variables',
                    \ 't:types',
                    \ 'n:interfaces',
                    \ 'w:fields',
                    \ 'e:embedded',
                    \ 'm:methods',
                    \ 'r:constructor',
                    \ 'f:functions'
                \ ],
                \ 'sro' : '.',
                \ 'kind2scope' : {
                    \ 't' : 'ctype',
                    \ 'n' : 'ntype'
                \ },
                \ 'scope2kind' : {
                    \ 'ctype' : 't',
                    \ 'ntype' : 'n'
                \ },
                \ 'ctagsbin'  : 'gotags',
                \ 'ctagsargs' : '-sort -silent'
            \ }

            " for markdown
            let g:tagbar_type_markdown = {
                \ 'ctagstype': 'markdown',
                \ 'ctagsbin' : '/Users/michaeltsui/bin/markdown2ctags.py',
                \ 'ctagsargs' : '-f - --sort=yes',
                \ 'kinds' : [
                    \ 's:sections',
                    \ 'i:images'
                \ ],
                \ 'sro' : '|',
                \ 'kind2scope' : {
                    \ 's' : 'section',
                \ },
                \ 'sort': 0,
            \}
        " ]]]
    " ]]]

    " 语言相关[[[2
        " pythonsyntax [[[3
            let python_highlight_all = 1
        " ]]]
        " go [[[3
            " format with goimports instead of gofmt
            let g:go_fmt_command = "goimports"
            let g:go_autodetect_gopath = 1
            let g:go_list_type = "quickfix"

            let g:go_highlight_build_constraints = 1
            let g:go_highlight_types = 1
            let g:go_highlight_fields = 1
            let g:go_highlight_functions = 1
            let g:go_highlight_methods = 1
            let g:go_highlight_extra_types = 1
            let g:go_highlight_generate_tags = 1
            let g:go_highlight_operators = 1
            let g:go_highlight_structs = 1

            let g:syntastic_go_checkers = ['golint', 'govet', 'errcheck']
            let g:syntastic_mode_map = { 'mode': 'active', 'passive_filetypes': ['go', 'java'] }

            if &filetype == 'go'
                nmap <Leader>h :GoDeclsDir<cr>
                imap <Leader>h <esc>:<C-u>GoDeclsDir<cr>
            endif


            augroup go
                autocmd!

                " Show by default 4 spaces for a tab
                autocmd BufNewFile,BufRead *.go setlocal noexpandtab tabstop=4 shiftwidth=4

                autocmd Filetype go map <C-n> :cnext<CR>
                autocmd Filetype go map <C-p> :cprevious<CR>
                autocmd Filetype go nnoremap <leader>a :cclose<CR>

                " :GoDef but opens in a vertical split
                autocmd FileType go nmap <Leader>v <Plug>(go-def-vertical)
                " :GoDef but opens in a horizontal split
                autocmd FileType go nmap <Leader>s <Plug>(go-def-split)

                " :GoAlternate  commands :A, :AV, :AS and :AT
                autocmd Filetype go command! -bang A call go#alternate#Switch(<bang>0, 'edit')
                autocmd Filetype go command! -bang AV call go#alternate#Switch(<bang>0, 'vsplit')
                autocmd Filetype go command! -bang AS call go#alternate#Switch(<bang>0, 'split')
                autocmd Filetype go command! -bang AT call go#alternate#Switch(<bang>0, 'tabe')
            augroup END

            " build_go_files is a custom function that builds or compiles the test file.
            " It calls :GoBuild if its a Go file, or :GoTestCompile if it's a test file
            function! s:build_go_files()
                let l:file = expand('%')
                if l:file =~# '^\f\+_test\.go$'
                    call go#cmd#Test(0, 1)
                elseif l:file =~# '^\f\+\.go$'
                    call go#cmd#Build(0)
                endif
            endfunction
        " ]]]
    " ]]]
" ]]]


" vim:fdm=marker:fmr=[[[,]]]
" vim:foldlevel=99
